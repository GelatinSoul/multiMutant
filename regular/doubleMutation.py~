#Double Mutation created by William Tian on May 21st, 2020.
#Uses multiMutant.sh (which in return uses ProMute) to mutate a given PDB ID twice.
#The results are consolidated into a file called "D_<PDBID><Chain><Range>_out"
#Redundant results are removed entirely, but the program still goes through the process of creating them.
#This is done through the use of a trie

import sys
import os

#Macros
TEMP_F = "temp_doubleMutationHelper" #Name of the temporary directory where we store the singly mutated sequences.

def echoPWD():
    print(os.popen('echo $PWD').read())

def getPath(argv):
    return argv[1] + argv[2] + argv[3] + '_out'

def createDir(t_f):
    if(os.path.exists(t_f)):
        os.system('rm -rf ' + t_f)
    os.system('mkdir ' + t_f)    

#Mutates a given sequence with the given parameters.
#argv[0] is never used. argv[1] is the PDB ID.
#argv[2] is the Chain (Note: Case sensitive). argv[3] is the range (Note: Inclusive on both ends).
#Essentially just calls ./multiMutant.sh with the command line arguments passed
def callMultiMutant(argv):
    fPath = getPath(argv)

    os.system('rm -rf ' + fPath)

    print('./multiMutant.sh ' + argv[1] + ' ' + argv[2] + ' ' + argv[3])
        
    
    os.popen('./multiMutant.sh ' + argv[1] + ' ' + argv[2] + ' ' + argv[3]).read()
    
    os.system('find ./' + fPath + ' -type d -empty -delete') #Removes redundant folders   

#MultiMutant.sh creates a bunch of PDB files across multiple folders in a new directory.
#This gathers all those files and puts them into a single temporary folder. Specified by t_f.
#This new folder will be discarded once the PDB files are mutated again, giving the original sequence two mutations.
def gatherPDBs(argv, t_f):
    fPath = getPath(argv)
    
    createDir(t_f)
    
    os.chdir('./' + fPath)
    for dirs in os.walk('.', topdown = False):
        if(dirs[0] != '.'):
            os.system('cp ' + dirs[0] + '/' + dirs[0] + '.pdb' + ' ../' + t_f)
    os.chdir('..')

#Moves the entire folder of sequences into one main folder.
def gatherDoubles(argv, t_f):
    fPath = getPath(argv)
    os.system('mv ' + fPath + '/* ' + t_f)
    os.system('rm -rf ' + fPath + ' ' + t_f + '/sequentialPipelineInvocation.sh')

#Uses a pdb_t, a trie, to check if a FASTA sequence is found. If it is, we remove the folder, as it's redundant.
def removeRedundants(dir, pdb_t):
    print(dir)
    os.chdir(dir)


    #Changes back to the root directory for this file
    os.chdir('..')
    
def mutateDirectory(argv):
    pdb_t = 0
    dir = 'D_' + argv[1] +  argv[2] + argv[3] + '_out'
    createDir(dir)
    
    for file in os.listdir(TEMP_F):
        if file.endswith("CRN.A10A.pdb"): ##Change this to .pdb to get all files!
            os.system('mv ' + TEMP_F + '/' + file + ' promute') #Moves the current file in the loop into ./promute/
            file = file.replace('.pdb', '')
            temp_argv = [0, file, argv[2], argv[3]] #Create a new argv, with the PDB ID as the file we just obtained
            callMultiMutant(temp_argv)
            os.system('rm ./promute/' + file + '.pdb')

            gatherDoubles(temp_argv, dir)
            removeRedundants(dir, pdb_t)
            #gatherPDBs(temp_argv, TEMP2_F)
            #t_f = file + argv[2] + argv[3] + '_out'
            #print(t_f)
            
        
    
def main():
    if(len(sys.argv) < 4):
        sys.exit("Please enter the correct command line arguments")
    callMultiMutant(sys.argv)
    gatherPDBs(sys.argv, TEMP_F)
    mutateDirectory(sys.argv)
    
if __name__ == "__main__":
    main()
